package lin.pattern.Creational.factorymethod.pattern;

public class FactoryPattern {
    /**
     * 工厂方法模式。Factory Method Pattern：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。
     * 工厂方法模式让一个类的实例化延迟到其子类。简称工厂模式。
     *
     * 角色：
     * Product 抽象产品  它是定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类
     * ConcreteProduct 具体产品  它实现了抽象产品接口，某种类型的具体产品有专门的具体工厂创建，具体工厂和具体产品之间意义对应。
     *
     * Factory抽象工厂   在抽象工厂类中，声明了工厂方法，用于返回一个产品。抽象工厂是工厂模式的核心。所有创建对象的工厂类必须实现该接口。
     * ConcreteFactory1 具体工厂 它是抽象工厂的子类，实现了抽象工厂中定义的工厂方法，可有客户端调用，返回一个具体产品类型的实例。
     *
     *
     * 思考 工厂方法模式中的工厂方法能否为静态方法？为什么？
     * 不能，因为工厂方法实际上是抽象方法，要求由子类来动态地实现，而动态性与static所声明的静态性相冲突
     *
     */
}
